TODO

- aggregate functions
  - `scalar.rs` -> `functions.rs`
  + `Aggregate` and `Window` structs? -> same thing, just a matter of invocation, aggregate if no 'OVER'
  + should it use `sqlite3_aggregate_context` or something else? -> No, not necessary
  + `create_aggregate_function` -> current design is closer to the actual sqlite design
  + `create_window_function` -> closer to the sqlite design
- vtab_in
  - `IndexInfo.is_in_operator(i32 constraint_idx)`
  - `IndexInfo.process_in_operator(constraint_idx: i32, value: bool)`
  - `api::iter_in_values(*mut sqlite3) -> Result<Vec<*mut sqlite3_value>>z`
- queries

  - `exec::prepare(db: *mut sqlite3, sql: &str) -> Result<Statement>`
  - `Statement.bind_int32(column_idx: i32, value: i32)`
  - `Statement.bind_text(column_idx: i32, value: &str)`
  - `Statement.bind_blob(column_idx: i32, value: &[u8])`
  - `Statement.execute() -> Iterator<Result<Row>>`
  - `Statement.execute_to_completion()`
  - `exec::execute(db, sql)`

- tests
  - charcters table func
  - some vtab to test argc/argv/argparse handling
  - vtab in tests
  - more exec tests
